<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2D Shooter Game</title>
    <style>
      canvas {
        display: block;
        margin: 0 auto;
        background: rgb(197, 197, 197);
      }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Load sprite images
      const idleImg = new Image();
      idleImg.src = 'sprites/prone_animaatio.png';
      
      const runningImg = new Image();
      runningImg.src = 'sprites/running_animation.png';

      const enemyImg = new Image();
      enemyImg.src = 'sprites/running animation vihu.png';

      const deadImg = new Image();
      deadImg.src = 'sprites/kuollu animaatio.png';
      
      // Sprite configuration
      const SCALE = 3.0; // Scale factor to make player bigger
      const spriteConfig = {
        idle: {
          img: idleImg,
          frameWidth: 30,
          frameHeight: 30,
          frames: { start: 0, count: 2 }, // Now 2 frames for idle
          animationSpeed: 5
        },
        moveLeft: {
          img: runningImg,
          frameWidth: 30,
          frameHeight: 30,
          frames: { start: 0, count: 4 }, // Assuming 4 frames for running left
          animationSpeed: 5
        },
        moveRight: {
          img: runningImg,
          frameWidth: 30,
          frameHeight: 30,
          frames: { start: 0, count: 4 }, // Assuming next 4 frames for running right
          animationSpeed: 5
        },
        jump: {
          img: idleImg,
          frameWidth: 50,
          frameHeight: 20,
          frames: { start: 0, count: 1 }, // Jump frame at index 2
          animationSpeed: 10
          
        }
      }
      const enemyConfig = {
  img: enemyImg,
  frameWidth: 30,    // adjust to your sprite width
  frameHeight: 30,   // adjust to your sprite height
  frames: { start: 0, count: 4 }, // how many frames enemy has
  animationSpeed: 5
};
;
      
      // Game variables
let player = {
  x: 400, 
  y: 500, 
  width: 50 * SCALE, 
  height: 20 * SCALE,
  state: 'idle',
  frameIndex: 0,
  animationCounter: 0,
  isJumping: false,
  vy: 0 // <--- add this
};
      let bullets = [];
      let enemies = [];
      let score = 0;
      
      // Key controls
      let keys = {};
      document.addEventListener('keydown', (e) => keys[e.key] = true);
      document.addEventListener('keyup', (e) => keys[e.key] = false);

      // Create enemies
function spawnEnemy() {
  const x = 0;
  enemies.push({ 
    x, 
    y: 500, 
    width: enemyConfig.frameWidth * SCALE, 
    height: enemyConfig.frameHeight * SCALE,
    frameIndex: 0,
    animationCounter: 0
    ,
    IsDead: false
  });
}

      
      // Update game state
      function update() {
        // Handle player movement and states
        let moving = false;
        let newState = player.state;
        
        if (keys['ArrowLeft'] && player.x > 0) {
          player.x -= 5;
          newState = 'moveLeft';
          moving = true;
        }
        if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
          player.x += 5;
          newState = 'moveRight';
          moving = true;
        }
        if (keys['ArrowUp'] && !player.isJumping) {
          player.isJumping = true;
          newState = 'jump';
          player.vy = -15; // jump strength
        }
        // Gravity and jumping
        if (player.isJumping) {
          player.vy += 1; // gravity
          player.y += player.vy;

          // Ground collision
          if (player.y >= 500) { // ground level
            player.y = 500;
            player.isJumping = false;
            player.vy = 0;
          }
        }

        
        // Reset to idle if not moving
        if (!moving && !player.isJumping) {
          newState = 'idle';
        }
        
        // Update state if changed
if (newState !== player.state) {
  player.state = newState;
  player.frameIndex = 0;            // start at first frame
  player.animationCounter = 0;      // reset animation

  const config = spriteConfig[player.state];
  player.width = config.frameWidth * SCALE;
  player.height = config.frameHeight * SCALE;
}


        // Shoot bullets
        if (keys[' ']) {
          bullets.push({ 
            x: player.x + player.width / 2 - 5, 
            y: player.y, 
            width: 10, 
            height: 20, 
            color: 'yellow' 
          });
          keys[' '] = false; // Prevent holding space
        }

        // Move bullets
bullets.forEach((bullet, index) => {
  bullet.x -= 10;
  if (bullet.x > canvas.width) bullets.splice(index, 1);
});


        // Move and animate enemies
enemies.forEach((enemy, index) => {
  enemy.x += 2;
  if (enemy.x > canvas.width) enemies.splice(index, 1);

  // animate enemy
  enemy.animationCounter++;
  if (enemy.animationCounter >= enemyConfig.animationSpeed) {
    enemy.animationCounter = 0;
    enemy.frameIndex = (enemy.frameIndex + 1) % enemyConfig.frames.count;
  }
});


        // Check collisions
        bullets.forEach((bullet, bIndex) => {
          enemies.forEach((enemy, eIndex) => {
            if (
              bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y
            ) {
              bullets.splice(bIndex, 1);
              enemies.splice(eIndex, 1);
              score++;
            }
          });
        });
        
        // Update player animation
        updatePlayerAnimation();
      }
      
      // Update player animation frame
      function updatePlayerAnimation() {
        const config = spriteConfig[player.state];
        
        player.animationCounter++;
        if (player.animationCounter >= config.animationSpeed) {
          player.animationCounter = 0;
          player.frameIndex = (player.frameIndex + 1) % config.frames.count;
        }
      }

      // Draw game objects
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw player sprite
        const config = spriteConfig[player.state];
        if (config.img.complete) {
          const frameX = (config.frames.start + player.frameIndex) * config.frameWidth;
          
          ctx.drawImage(
            config.img,
            frameX, 0, // Source x, y
            config.frameWidth, config.frameHeight, // Source width, height
            player.x, player.y, // Destination x, y
            player.width, player.height // Destination width, height (scaled)
          );
        } else {
          // Fallback to rectangle if image not loaded
          ctx.fillStyle = 'green';
          ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        // Draw bullets
        bullets.forEach(bullet => {
          ctx.fillStyle = bullet.color;
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw enemies
// Draw enemies
enemies.forEach(enemy => {
  if (enemyConfig.img.complete) {
    const frameX = (enemyConfig.frames.start + enemy.frameIndex) * enemyConfig.frameWidth;
    ctx.drawImage(
      enemyConfig.img,
      frameX, 0, // source x,y
      enemyConfig.frameWidth, enemyConfig.frameHeight, // source width,height
      enemy.x, enemy.y, // destination x,y
      enemy.width, enemy.height // destination width,height
    );
  } else {
    // fallback rectangle
    ctx.fillStyle = 'red';
    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
  }
});

        // Draw score
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
      }

      // Game loop
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      // Start game
      setInterval(spawnEnemy, 1000); // Spawn enemies every second
      gameLoop();
    </script>
</body>
</html>